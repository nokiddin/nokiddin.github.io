<!DOCTYPE html>
<!-- adapted from url=http://mdaines.github.io/viz.js/form.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>dot -&gt; svg</title>
    <style type="text/css">
      
    #divtlb {
      height: 20px;
	  background: yellow;
    }
    #input {
      width: 500px;
      height: 300px;
    }

	#divinput {
		display: none;
	}
	
	#diverror {
		display: none;
		background: red;
	}

	.cmnuitem {
		text-decoration:underline;
		cursor:pointer;
	}
      
    </style>
  </head>
  <body>
	<div id="divtlb"> <!-- toolbar -->
	<span class="cmnuitem" id="mnuEdit" onclick="show_input('mnuEdit','toggle');">Show Editor</span>
	<span class="cmnuitem" id="mnuPublish">Publish URL</span>
    <a href="samples.html">Samples</a>    
	</div>
	<div id="divinput"> 
    <p><textarea id="input" spellcheck="false">digraph G {

}
	</textarea></p>
    <p><button id="generate">Visualize</button></p>
    <!-- <p><button id="btnPublish">Publish URL</button></p> -->
	</div>
	<div id="diverror">
	<span class="cmnuitem" id="mnuErr" onclick="show_item('diverror','mnuErr',null,'hide');">Hide</span>&nbsp;<span id="wdgerror"></span>
	</div>

    <div id="divpuburi"><a id="puburi" href=""></a></div>
    <div id="output"></div>
    <div id="inspect"></div>
    
    <!-- <script src="http://nokiddin.github.io/viz.js"></script> -->
    <script src="viz.js"></script>
    <script>
	function wrapasdigraph(x, done){
		if(x.match(/^ *digraph/)){
			done(x);	
		}else{
			done("digraph{\n" + x + "\n}");
		}
	}
	function urldecode(s){
		return decodeURI(s);
	}
	function mkuri(s){
		return encodeURI(s);
	}
	function readfragment(s, done){
		function failed(){done({}); return 0;}
		if(!s || s.charAt(0)!="#") { return failed(); }

		s = decodeURI(s);
		var frgtypendx=s.indexOf(":");
		if(frgtypendx < 0) return failed();

		var frgtype=s.substring(1,frgtypendx);
		var frgdata=s.substr(frgtypendx+1);
		var flag=""; 		
		var cc=0;
		var wrapper; //func_type
		var fetch; //func_type
		for(cc=0; cc<frgtype.length; cc++){
			var ch=(frgtype.charAt(cc));
			if(ch=='d'){
				flag+=",grf";
			}else if(ch=='D'){
				flag+=",grf";
				fetch=linkfetch;
			}else if(ch=='s' ||ch=='e')
				flag+=",src";
			else if(ch=='x')
				flag+=",dbg";
			else if(ch=='t')
				flag+=",tlb";
			else if(ch=='w'){
				wrapper=wrapasdigraph;
			}
		}
		function noop(buffer,done){return done(buffer);}
		function linkfetch(linkurl,done){ezxhr(linkurl,function(failure,txt){done(failure?null:txt,failure);},"text/plain");}
		if(!fetch) fetch=noop;	
		if(!wrapper){ wrapper=noop;}

		fetch(frgdata, function(d,error){
			if(d){
				wrapper(d, function(wd){ 
					done({data:wd, flag:flag});
				});
			}else{
				displayerror(
					"ERROR: Could not load data. This error usually occurs if the source server you are referencing does not support CORS headers." +
					(error?error.message:""));
			}
		});
	}
	function generate_uri(sdot, notiny, done){
		var rootpage= 
			"http://nokiddin.github.io/graphviz.html";
			//"";
		
		//#CdDdt:
		//nugget syntax: content-type-header content-type (size-header size-in-octets size-suffix)*0 data-header data-flags*0 colon data
		var uri = rootpage + "#dt:"+mkuri(sdot);
		if(!!notiny) done(uri); else leggytinyurl(uri, done);
	}
	function _viz(){
		var rv;
		try{
			rv = Viz.apply(this, arguments);
		}catch(e){
			rv = null;
		}
		return rv;
	}
	function generate_svg(sdot){
		var engine="dot"; //"neato"
		var svg=_viz(sdot, "svg", engine); 
		return result = svg?{svg:svg}:{error:"SYNTAX ERROR IN DIGRAPH" } ;
	}
	function setinnertext(el,tx){
		el.innerText=el.textContent=tx;
	}
	function show_input(mnuid, purpose){
		return show_item("divinput",mnuid,{hide:"Hide Editor",show:"Show Editor"},purpose);
	}
	function show_item(targetid, mnuid, mnutxt, purpose){
		mnutxt=mnutxt||{hide:"Hide",show:"Show"};
		var is_visible=(el(targetid).style.display!="none");
		if(!purpose || purpose=="hide" || purpose=="false"){
			is_visible=false;
		}else if(purpose=="toggle"){
			is_visible=!is_visible;
		}else if(purpose===true || purpose=="show" || purpose=="true"){
			is_visible=true;
		}
		el(targetid).style.display=is_visible?"inherit":"none";
		setinnertext(el(mnuid), is_visible?(mnutxt["hide"]):(mnutxt["show"]));
	}
	function onload_(){
		readfragment(window.location.hash, function(input){
		if(input && input.data){
			
			var bshowsrc, bshowgrf;
			bshowgrf = (input.flag && (","+input.flag+",").match(/,grf,/));
			bshowsrc = (input.flag && (","+input.flag+",").match(/,src,/));
			bshowdbg = (input.flag && (","+input.flag+",").match(/,dbg,/));
			bshowtlb = (input.flag && (","+input.flag+",").match(/,tlb,/));

			el("divinput").style.display=bshowsrc?"inherit":"none";
			el("input").value=input.data;
			displayresults(generate_svg(input.data), {showgrf:bshowgrf, showdbg:bshowdbg});
		}else{
			el("divinput").style.display="inherit";
		}
		});
	}
	window.onload=onload_;
	
    function inspect(s) {
      return "<pre>" + s.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;") + "</pre>";
    }
	function el(id){
		return document.getElementById(id);
	}

	//sets item html and then renders (shows/hides) it or an associated item  
	//value is treated as html by default, or as text if astext is set.
	//visible is true / false. 
	function render(id, value, visible, associateid, astext){
		//set it even for display:none case, for any programmatic dom access. 
		if(!astext)
			el(id).innerHTML = value;
		else
			setinnertext(el(id),value); 
		associateid=associateid||id;
		el(associateid).style.display=visible?"inherit":"none";
	}
	function render_a(id, uri, visible){
		if(!el(id).href) return ;

		// generate tinyurl using leggy if enabled. 
		(function(done){
			var TINYMAKER="none"; // disabled until leggy developers add CORS support. 
			
			if(TINYMAKER=="leggy")
				leggytinyurl(uri, done);
			else if(TINYMAKER=="none")
				done(false, {shortUrl:uri}, null);

		})(function(failure, data){ el(id).href = data.shortUrl; } );
		setinnertext(el(id), uri);
		el(id).style.display=visible?"inherit":"none";
	}
	function displayerror(errortxt){
		render("wdgerror",errortxt,true,"diverror",true);
	}
	function displayresults(results, displayopts){
		if(results.error){
			displayerror(results.error);
		}
		if(results.svg){
			render("output", results.svg, displayopts.showgrf);
			render("inspect", inspect(results.svg), displayopts.showdbg);
		}
		if(results.uri){
			render_a("puburi", results.uri, displayopts.showuri);
		}
	}
	
    ["btnPublish","mnuPublish"].forEach(function(ii){
		var xel=el(ii); 
		if(xel) xel.addEventListener("click", function(e){
			//Temporarily disabling tinyurl generation as our generator leggy.io ain't CORS-friendly.
			//Other generators are excessively ad-friendly. 
			var uri = generate_uri(el("input").value, true, function(uri){
				displayresults({uri:uri, dspuri:uri}, {showuri:true});
			});
		});
	});
	/*
	el("puburi").addEventListener("click", function(e){
		onload_();
	}); */
    el("generate").addEventListener("click", function(e) {
      var result = generate_svg(el("input").value);
      
      if (result && result.svg) {
		displayresults(result, {showgrf:true});
      } else {
        displayresults({svg:""}, {showgrf:true});
      }
      
    });
   
    function _get_content_type(headers){ //headers can be an array of headers or a single header string.
		var hct ; //content type header serialized
		var charset; //charset part only
		var ct ;  //content-type part only
		var outdata = null;
		if(headers){ //de-multiplex array of headers and a single string header. 
			if(typeof headers =='string')
				hct=headers;
			else (hct = headers["content-type"]);
			
			if(hct){
				var c = hct.split(';');
				if(c[0].trim() == "text/plain"){
					cs = c[1].split('=');
					if(cs[0].trim() == "charset"){
						charset = cs[1].trim();
					}   
					ct = c[0].trim();
				}   

			// we're good if charset looks like utf8 or utf-8  mixed/upper/lowercase etc.
				outdata={ content_type: ct };
				outdata.charset = ((charset.search(/utf-?8/i)>=0)? "utf8":charset);
			}
		}   
		return outdata;
	}

	//derivative of https://gist.github.com/4706967 
	// XXXxhrget 
	//cb is  function(boolean failure, data_t jsonortxt, xhr_t xhrobject)
	// outct is the  content-type desired in the response.
	// jsonortxt is either a json object or a text string.
	function ezxhr(url,cb,outct,timeout){
		return quickxhr(url,cb,{outct:outct,timeout:timeout});
	}

	/*
	options: {
		method : "GET" (default, unless inpobj is set) ; "POST", "HEAD", etc.
		inpobj : non-null if sending an object. Sending invokes the method requested. If set, POST is default method. 
		inpct  : defaults to "application/json" if sending an object.
		outct  : desired content-type in the response. Defaults to "application/json".
		timeout: requested timeout in millisec.
	}
	The default 'options' is : {method:"GET",outct:"application/json",timeout:8000}
	*/
	function quickxhr(url,cb,options){
		cb = cb || function(failure, jsonortxt, xhrobject){}
		options=options||{};
		var post=options.inpobj;
		var inpct=post?(options.inpct||"application/json"):null;
		var method=options.method?options.method.toUpperCase():(post?"POST":"GET");
		var outct=options.outct||"application/json";
		var timeout=options.timeout||8000;
		
		var xhr;
		function failed(e_,cb,xhr){
				var e=(typeof(e_)==="string")?(new Error(e_)):e_; 
				if(console)console.log(e.message);
				return cb(e,null,xhr);
			};
		try{ xhr = new XMLHttpRequest(); }catch(e){
			try{ xhr = new ActiveXObject("MSXML2.XMLHTTP"); }catch (e){
				return failed(e,cb,xhr);
			}
		}
		try{
			var ontimeout=function() {xhr.abort(); return failed("quickxhr: timeout",cb,xhr); } 
			var ftimer;
			ftimer = setTimeout(ontimeout , timeout);
			//TODO: use xhr timeouts : (not all browsers supported)
			//see :https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
			//xhr.ontimeout=ontimeout;
			
			//The below line is stubbed out cuz I don't know how to xlate from progressevt to error. 
			//xhr.onerror=function(progressevt){ failed(null,cb,xhr); }; 
			xhr.onreadystatechange = function() {
				if (xhr.readyState != 4) return;
				clearTimeout(ftimer);
				if(xhr.status == 200){
					var rct=_get_content_type(xhr.getResponseHeader("Content-Type")); 
					if(!rct || rct.content_type!=outct) { return failed("quickxhr: No Content Type",cb,xhr); } 
					var rv = xhr.responseText;
					if(rct.content_type=="application/json"){ try { rv=JSON.parse(rv); } catch(e){ return failed(e,cb,xhr); }}
					return cb(null, rv, xhr); 
				}else { 
					return failed("quickxhr: server response status is "+xhr.status,cb,xhr);
				} 
			}
			xhr.open(method?method.toUpperCase():"GET", url, true);
			xhr.withCredentials = true;

			if(!post){
				xhr.send();
			}else {
				xhr.setRequestHeader('Content-Type', inpct);
				xhr.send(post);
			}
		}catch(e){
			return failed(e,cb,xhr);
		}
	}

	function jsonxhr(url,cb,method,post,reqct,timeout) {
		cb = cb || function(failure, jsonortxt, xhrobject){}
		var ftimer, xhr;
		try{ xhr = new XMLHttpRequest(); }catch(e){
		try{ xhr = new ActiveXObject("Msxml2.XMLHTTP"); }catch (e){
		if(console)console.log("tinyxhr: XMLHttpRequest not supported");
		cb(e);
		}
		}
		ftimer = setTimeout(function() {xhr.abort(); cb(new Error("xhr: aborted by a timeout"), "",xhr); } , timeout?timeout:8000);
		xhr.onreadystatechange = function()
		{
		if (xhr.readyState != 4) return;
		clearTimeout(ftimer);
		if(xhr.status == 200){
		var rct=_get_content_type(xhr.getResponseHeader("Content-Type")); 
		if(!rct){ cb(new Error("Bad Content Type")); return ; } 
		var rtxt=xhr.responseText; 
		var rjson;
		if(rct.content_type=="application/json"){ try { rjson=JSON.parse(rtxt); } catch(e){ cb(e); }}
		cb(false, rjson || rtxt, xhr); 
		}else { 
		cb(new Error("xhr: server response status is "+xhr.status));
		} 
		}
		xhr.open(method?method.toUpperCase():"GET", url, true);

		//xhr.withCredentials = true;

		if(!post)
		xhr.send();
		else {
			xhr.setRequestHeader('Content-Type', reqct?reqct:'application/json');
			xhr.send(post);
		}
	}	

	function leggytinyurl(url, done){
		quickxhr("http://leggy.io/api/v1/shorten", done, {method:"POST", inpobj:{longUrl:url}});
	}

	</script>
    
<!--
 vim: ft=html:noet:ts=2:sts=2:sw=2:
-->
</body></html>
